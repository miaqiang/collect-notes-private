# HTTP协议

## 问题

1. HTTP协议的主要特点
2. HTTP报文的组成部分
3. HTTP方法
4. POST和GET的区别
5. HTTP状态码
6. HTTP持久连接
7. 什么是管线化
8. HTTPS
9. HTTP2.0
10. 常见HTTP首部字段
11. HTTP1.1和HTTP1.0的区别？
12. HTTP与TCP如何协同工作的，TCP怎么确保HTTP传输的稳定有序 ？

## 回答

###  1. HTTP协议的主要特点

- 1.简单快捷

  > 每个资源url都是固定的，一个页面地址一张图片叫做统一资源符，这个是固定的，所以在http协议中处理也是非常简单的。我想访问这个一个地址，只要输入这一个url就可以了。

- 2.灵活

  > 在http协议中有的头部会有一个数据类型，通过一个http协议就可以完成不同数据类型的传输。

- 3.无连接

  > 连接一次它就会掉，不会保持连接；
  >
  > 

- 4.无状态

  > 客户端和服务端是两种身份，客户端需要向服务端请求一个图片，那么http协议建立连接，帮你中间传输。这次任务完成以后，连接就要断开了，下次客户端再过来服务端是没法区分上一次连接和这一次连接是不是同一个身份。因为服务端是没有记住你的状态的。但从http协议上是不能区分两次连者的身份的。

### 2. HTTP报文的组成部分

> 浏览器向服务器要一个html文档或者一个图片时，输入xxxx.com，相当于客户端发出的请求报文；发出去了，服务端接受到了以后做出响应，要不要给你这份文档的内容，这个就是响应报文；



- 请求报文：

  - 请求行（GET/HTTP/1.1）

    包含：http方法、页面地址、http协议、版本

  - 请求头

    key、value值来告诉服务端要哪些内容，注意哪些类型

  - 空行

    当遇到空行就知道不是在请求头部分了，就改当请求体来解析了

  - 请求体

- 响应报文：

  - 状态行（HTTP/1.1  200 ok --http状态码）

  - 响应头

    key、value值来告诉服务端要哪些内容，主要哪些类型

  - 空行

  - 响应体

    比如返回的图片

### 3. HTTP方法

```
GET------获取资源
POST-----传输资源
PUT------修改资源
DELETE---删除资源（一般业务是不删除资源的，标记）
HEAD-----获取报文首部

GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
OPTIONS：查询相应URI支持的HTTP方法。
```



### 4. POST和GET的区别

```
1.GET在浏览器回退时是无害的，而POST会再次提交请求
2.GET产生的URL地址可以被收藏，而POST不可以
3.GET请求会被浏览器主动缓存，而POST不会，除非手动设置
4.GET请求只能进行URL编码，而POST支持多种编码方式
5.GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留
    --	想把参数留在浏览器历史记录里用GET，为了防止crsf攻击，大部分get改为POSt
    如果业务需要把参数留在浏览器历史记录中，记得把POST改为GET。
6.GET请求在URL中传送的参数是有长度限制的（2kb），而post没有限制
	如果用的是GET请求，拼接的URL不要太长，否则会被浏览器截断，因为http协议对这个长度是有限制的。
	发布出去，导致截断这种情况，一段被截断，你的服务器拿不到正确的地址，获取不到资源的。
7.对参数的数据类型，GET只接受ASCII字符，而post没有限制
8.GET比POST更不安全，因为蚕食直接暴露在URL上，所以不嫩用来传递敏感信息
9.GET参数通过URL传递，POST放在Request body中

```



### 5. HTTP状态码

- 1XX :提示信息--表示请求已接受，继续处理

- 2xx：成功--表示请求已经被成功接受

  - 200 ok:客户端请求成功
  - 204：请求被受理但没有资源可以返回
  - 206 Partial Content：客户端发送了一个带有Range（范围）头的GET请求，服务器完成了它
              （客户端请求一部分内容，在http head头中有一个range范围，请求0-10000字节，服务器就
       返回一个206，服务器的文件是完整的，这个时候看到range头，按照range头从整个文件中截取一部分响应
      给你，你响应体中只有你range头中指定的内容）
        使用video播放视频地址，audio播放音频地址，当视频文件、音频文件很大的时候基本都是返回的206;
  
- 3xx：重定向--要完成请求必须进行更进一步的操作
  
   - 301 Moved Permanently：（永久重定向）所请求的页面已经转移至新的URL
   
  - 302 Found：（临时重定向）所请求的页面已经临时转移至新的URL
  
  - 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
  
  - 304 Not Modified：客户端有缓冲的文档并发出一个条件下的请求，服务器告诉客户端，原来缓存的文档还可以继续使用。
  
    （服务器告诉浏览器已经有缓存了，可以直接从缓存中去取文档用，不用去服务器取了）
  
    **304缓存的原理**
    
    服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该几号传回服务器要求服务器验证其（客户端）缓存。
    
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到这个状态码后，会使用浏览器已缓存的文件
    
    客户端请求一个页面（A）。服务端返回页面A，并在A加上一个ETag。客户端展现该页面，并将页面连同ETag一起缓存，客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。
    服务器检查该ETag，并判断出该页面自上课客户端请求之后还未被修改。直接返回响应304（未修改——not modified）好一个空的响应体
    
    307：临时重定向，与302类似，只是强制要求使用POST方法
  
- 4xx：客户端错误-- 请求有语法错误或请求无法实现

  - 400 Bad Request：客户端请求有语法错误，不能被服务器所理解；

  - 401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用;

  - 403 Forbidde：对被请求页面的访问被禁止（资源禁止被访问）

    （看到一个页面中一个地址，这个地址真的访问又不允许直接访问，只能通过服务器去访问;）

  - 404 Not Found：请求资源不存在；

- 5xx：服务器错误--服务器未能实现合法的请求

  - 500 Internal Server Error：服务器发生不可预期的错误，原来缓存的文档还可以继续使用；
  - 503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可能恢复正常。



### 6. HTTP持久连接

​	HTTP是支持持久连接的，1.1版本才支持，1.0版本支持

- 非持久连接：

  > HTTP 协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive（持久连接）模式时，每个请求/应答客户端和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）

- 持久连接
  
  - 当使用Keep-Alive模式（持久连接，连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，Keep-Alive功能避免了建立或者重新建立连接。
  
-  HTTP1.1版本新特性

  a、默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求

  b、管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应

  c、断点续传原理

### 7. 什么是管线化

请求和响应共用一个通道，这个通道是持久建立的，不是我请求一次你响应一次，而是把请求打包一次传输过去，你也打包一次响应过来

 在使用持久连接的情况下，某个连接上消息的传递类似于：
		--请求1-->响应1-->请求2-->响应2-->请求3-->响应3（表示整个连接没有中断过）

某个连接上的消息变成了类似这样：（持久连接情况下完成的管线化）
		请求1-->请求2-->请求3-->响应1-->响应2-->响应3

1. 管线化机制通过持久连接完成，仅HTTP/1.1支持此技术；
2. 只有GET和HEAD请求可以进行管线化，而POST则有所限制；
3. 初次建立连接时不会启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议；
4. 管线化不会影响响应到来的顺序，返回的顺序不会改变
5. HTTP/1.1要求服务器端支持管线化，但并不要求服务器端也会响应进行管线化处理，只是要求对于管线化的请求不失败即可；
6. 由于上面提到的服务器问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如Chrome和Firefox默认未开启管线化支持。



总结：1. 工作原理：将请求响应打包回来（通过持久连接完成，需要HTTP/1.1支持）；

​			2.只有GET和HEAD请求可以进行管线化，POST有所限制

​			3.连接的时候不要启动管线限制，因为对方可能不支持（初次连接的时候）。



### 8. HTTPS

- HTTP的缺点
  - a、通信使用明文不加密，内容可能被窃听
  - -b、不验证通信方身份，可能遭到伪装- 
  -  c、无法验证报文完整性，可能被篡改

- HTTPS

​	HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL和TSL），这个时候，就成了	我们常说的HTTPS。

​	默认HTTP的端口号是80.HTTPS的端口号是443

> 为什么HTTPS安全

因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。HTTPS之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性

### 9.HTTP2.0

HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户需要数据之前就主动将数据发送到客户缓存中，从而提高性能

HTTP/2提供更多的加密支持

HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。

它增加了头压缩（head compression），因此即使非常小的请求，其请求和响应的header都只会占很小比例的贷款。

### 10.常见HTTP首部字段

a、通用首部字段（请求报文与响应报文都会使用的首部字段）

```
Date：创建报文时间
Connection：连接的管理
Cache-Control：缓存的控制Transfer-Encoding：报文主体的传输编码方式
```

b、请求首部字段（请求报文会使用的首部字段）

```
Host：请求资源所在服务器
Accept：可处理的媒体类型
Accept-Charset：可接收的字符集
Accept-Encoding：可接受的内容编码
Accept-Language：可接受的自然语言
```

c、响应首部字段（响应报文会使用的首部字段）

```
Accept-Ranges：可接受的字节范围
Location：令客户端重新定向到的URI
Server：HTTP服务器的安装信息
```



d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）

```
Allow：资源可支持的HTTP方法
Content-Type：实体主类的类型
Content-Encoding：实体主体适用的编码方式
Content-Language：实体主体的自然语言
Content-Length：实体主体的的字节数
Content-Range：实体主体的位置范围，一般用于发出部分请求时使用
```

### 11. HTTP1.1和HTTP1.0的区别？

> 在同一个tcp的连接中可以传送多个HTTP请求和响应.
> 多个请求和响应可以重叠，多个请求和响应可以同时进行.
>
> 更加多的请求头和响应头(比如HTTP1.0没有host的字段).



>  总之，在 HTTP/1.0 中,大多实现为每个请求/响应交换使用新的连接。在 HTTP/1.1 中,一个连接可用于一次或多次请求/响应交换,尽管连接可能由于各种原因被关闭.这是他们之间最大区别



>  TCP 有一个特性叫做 slow start，其含义可以大致这样解释：TCP 连接要求发送端发送一定数量的网络包之后接收端就要回一个“我收到”的网络包，而且网络包在经过每个路由器的时候包头都要被重写，所以在网络不丢包的情况 下网络包越大网络的效率就越高。TCP 连接寻找最优网络包大小的方法是，在 TCP 连接建立的初期，网络包的大小是很小的，根据网络状况，两端的程序才会逐步增大网络包的大小以适应带宽提高网络传输的效率。所以浏览器给服务器发请求，如 果每发一个请求就关闭连接的话，那这个连接的数据传输很难达到带宽所能承载的速度。



>  HTTP1.1 提出了持久连接（persistent connection）的概念，也就是说同一条 HTTP 连接，可以同时处理多个请求，同时用一定的机制保证各个请求之间的分离性。具体的操作过程是：服务器给浏览器发送回应之后，并不马上关闭连接；浏览器判断 上一个请求的回应已经收完的情况下，可以在这同一个连接上发第二个请求。这种运作模式大大减少了网络包，实验也表明这种做法很有效。但是，由于服务器上保 持连接要占用一定的资源，所以一般服务器不会永久保持持久连接，而且也不推荐浏览器和服务器之间建立过多的持久连接。



### 12.HTTP与TCP如何协同工作的，TCP怎么确保HTTP传输的稳定有序 ？

> HTTP/1.0和HTTP/1.1都把TCP作为底层的传输协议。HTTP客户首先发起建立与服务器TCP连接。一旦建立连接，浏览器进程和服务器进 程就可以通过各自的套接字来访问TCP。如前所述，客户端套接字是客户进程和TCP连接之间的“门”，服务器端套接字是服务器进程和同一TCP连接之间的 “门”。客户往自己的套接字发送HTTP请求消息，也从自己的套接字接收HTTP响应消息。类似地，服务器从自己的套接字接收HTTP请求消息，也往自己 的套接字发送HTTP响应消息。客户或服务器一旦把某个消息送入各自的套接字，这个消息就完全落入TCP的控制之中。TCP给HTTP提供一个可靠的数据 传输服务;这意味着由客户发出的每个HTTP请求消息最终将无损地到达服务器，由服务器发出的每个HTTP响应消息最终也将无损地到达客户。我们可从中看 到分层网络体系结构的一个明显优势——HTTP不必担心数据会丢失，也无需关心TCP如何从数据的丢失和错序中恢复出来的细节。这些是TCP和协议栈中更 低协议层的任务。



> TCP还使用一个拥塞控制机制。该机制迫使每个新的TCP连接一开始以相对缓慢的速率传输数据，然而只要网络不拥塞，每个连接可以迅速上升到相对较高的速率。这个慢速传输的初始阶段称为缓启动(slow start)。



> 需要注意的是，在向客户发送所请求文件的同时，服务器并没有存储关于该客户的任何状态信息。即便某个客户在几秒钟内再次请求同一个对象，服务器也不会响 应说:自己刚刚给它发送了这个对象。相反，服务器重新发送这个对象，因为它已经彻底忘记早先做过什么。既然HTTP服务器不维护客户的状态信息，我们于是 说HTTP是一个无状态的协议(stateless protocol)。

## 参考

-  [从输入 URL 到页面加载完成的过程中都发生了什么事情？](https://www.jianshu.com/p/71cf7f69eca8)

-  [OSI七层模型与TCP/IP五层模型](https://www.cnblogs.com/qishui/p/5428938.html)

-  [说说网络分层里七层模型是哪七层](../html/说说网络分层里七层模型是哪七层.md)

-  [TCP和UDP的区别](../html/TCP和UDP的区别.md)

- [从输入 URL 到页面加载完成发生了什么事](https://segmentfault.com/a/1190000002611809)

- [浏览器渲染原理及流程](https://www.cnblogs.com/slly/p/6640761.html)

- [TCP三次握手及四次挥手详解及常见面试题](https://blog.csdn.net/ZWE7616175/article/details/80432486)

- [http全过程](https://segmentfault.com/a/1190000007033157#articleHeader1)

- [前端常见跨域解决方案](html/前端常见跨域解决方案.md)

  